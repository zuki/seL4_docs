<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RefOS: apps/process_server/src/system/process/process.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="header-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RefOS
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Multi-server operating system on seL4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('process_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">process.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Process management module for process server.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vmlayout_8h_source.html">refos/vmlayout.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rpc_8h_source.html">refos-rpc/rpc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="cvector_8h_source.html">data_struct/cvector.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="common_8h_source.html">../../common.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="vspace_8h_source.html">../addrspace/vspace.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="process__server_2src_2system_2memserv_2dataspace_8h_source.html">../memserv/dataspace.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ringbuffer_8h_source.html">../memserv/ringbuffer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="proc__client__watch_8h_source.html">proc_client_watch.h</a>&quot;</code><br />
</div>
<p><a href="process_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structproc__pcb.html">proc_pcb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process control block structure.  <a href="structproc__pcb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3270c8e6928a8be1b271a39dbf3a4db4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a3270c8e6928a8be1b271a39dbf3a4db4">REFOS_PCB_MAGIC</a>&#160;&#160;&#160;0xB33FFEED</td></tr>
<tr class="separator:a3270c8e6928a8be1b271a39dbf3a4db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4380c6c2dbdf96c0fda83545d94beaad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a4380c6c2dbdf96c0fda83545d94beaad">REFOS_PCB_DEBUGNAME_LEN</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a4380c6c2dbdf96c0fda83545d94beaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a16df8f836baf66dadfbf7f931f809"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a24a16df8f836baf66dadfbf7f931f809">PROCESS_PERMISSION_DEVICE_MAP</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a24a16df8f836baf66dadfbf7f931f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4530a640ac0e101963c9c6684a5f02e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#ad4530a640ac0e101963c9c6684a5f02e">PROCESS_PERMISSION_DEVICE_IRQ</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:ad4530a640ac0e101963c9c6684a5f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659202ebb2150def5660572a3259aacf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a659202ebb2150def5660572a3259aacf">PROCESS_PERMISSION_DEVICE_IOPORT</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:a659202ebb2150def5660572a3259aacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a545b9250f16d07300f38e88fc792a40a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a545b9250f16d07300f38e88fc792a40a">proc_config_new</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p, uint32_t pid, uint8_t priority, char *imageName, uint32_t systemCapabilitiesMask)</td></tr>
<tr class="memdesc:a545b9250f16d07300f38e88fc792a40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up and configure a process.  <a href="process_8h.html#a545b9250f16d07300f38e88fc792a40a">More...</a><br /></td></tr>
<tr class="separator:a545b9250f16d07300f38e88fc792a40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fd694f51d9da8312851ab2ec5fbe4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a86fd694f51d9da8312851ab2ec5fbe4a">proc_start_thread</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p, int tindex, void *arg0, void *arg1)</td></tr>
<tr class="memdesc:a86fd694f51d9da8312851ab2ec5fbe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a process' thread running.  <a href="process_8h.html#a86fd694f51d9da8312851ab2ec5fbe4a">More...</a><br /></td></tr>
<tr class="separator:a86fd694f51d9da8312851ab2ec5fbe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471a33059ac7950175d1568e2ef9cf53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a471a33059ac7950175d1568e2ef9cf53">proc_load_direct</a> (char *name, int priority, char *param, unsigned int parentPID, uint32_t systemCapabilitiesMask)</td></tr>
<tr class="memdesc:a471a33059ac7950175d1568e2ef9cf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly load an ELF into a process.  <a href="process_8h.html#a471a33059ac7950175d1568e2ef9cf53">More...</a><br /></td></tr>
<tr class="separator:a471a33059ac7950175d1568e2ef9cf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b752c4db755479adeeae57a5e982418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a5b752c4db755479adeeae57a5e982418">proc_release</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p)</td></tr>
<tr class="memdesc:a5b752c4db755479adeeae57a5e982418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a process, and delete all its owned resources.  <a href="process_8h.html#a5b752c4db755479adeeae57a5e982418">More...</a><br /></td></tr>
<tr class="separator:a5b752c4db755479adeeae57a5e982418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dc33fc12015bdaa41a9ae60770a789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#ad3dc33fc12015bdaa41a9ae60770a789">proc_queue_release</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p)</td></tr>
<tr class="memdesc:ad3dc33fc12015bdaa41a9ae60770a789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a process to be released at the next <a class="el" href="process_8h.html#a696b07bb3c46870b9e35f913b515eded" title="Perform any process book-kepping postactions.">proc_syscall_postaction()</a> call.  <a href="process_8h.html#ad3dc33fc12015bdaa41a9ae60770a789">More...</a><br /></td></tr>
<tr class="separator:ad3dc33fc12015bdaa41a9ae60770a789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95532e638ce424d70b91b5509541918"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#af95532e638ce424d70b91b5509541918">proc_nice</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p, int tindex, int priority)</td></tr>
<tr class="memdesc:af95532e638ce424d70b91b5509541918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the priority for a given process' thread.  <a href="process_8h.html#af95532e638ce424d70b91b5509541918">More...</a><br /></td></tr>
<tr class="separator:af95532e638ce424d70b91b5509541918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9267fe695f757ab014803103524bef7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#aa9267fe695f757ab014803103524bef7">proc_set_parambuffer</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p, struct <a class="el" href="structram__dspace.html">ram_dspace</a> *paramBuffer)</td></tr>
<tr class="memdesc:aa9267fe695f757ab014803103524bef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the parameter buffer for a process.  <a href="process_8h.html#aa9267fe695f757ab014803103524bef7">More...</a><br /></td></tr>
<tr class="separator:aa9267fe695f757ab014803103524bef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775dc91d0609d182f8c83fdfb7c40b18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a775dc91d0609d182f8c83fdfb7c40b18">proc_set_notificationbuffer</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p, struct <a class="el" href="structram__dspace.html">ram_dspace</a> *notifBuffer)</td></tr>
<tr class="memdesc:a775dc91d0609d182f8c83fdfb7c40b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the async notification buffer for a process.  <a href="process_8h.html#a775dc91d0609d182f8c83fdfb7c40b18">More...</a><br /></td></tr>
<tr class="separator:a775dc91d0609d182f8c83fdfb7c40b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56582b3cfefbbdaed5c74d9cab6fe60a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a56582b3cfefbbdaed5c74d9cab6fe60a">proc_dspace_delete_callback</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p, void *cookie)</td></tr>
<tr class="memdesc:a56582b3cfefbbdaed5c74d9cab6fe60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge all references to a dataspace.  <a href="process_8h.html#a56582b3cfefbbdaed5c74d9cab6fe60a">More...</a><br /></td></tr>
<tr class="separator:a56582b3cfefbbdaed5c74d9cab6fe60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1123288e3ffe218e7da3d5773d815fe"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structproc__tcb.html">proc_tcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#ad1123288e3ffe218e7da3d5773d815fe">proc_get_thread</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p, int tindex)</td></tr>
<tr class="memdesc:ad1123288e3ffe218e7da3d5773d815fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread TCB of process at the given threadID.  <a href="process_8h.html#ad1123288e3ffe218e7da3d5773d815fe">More...</a><br /></td></tr>
<tr class="separator:ad1123288e3ffe218e7da3d5773d815fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7e6309fe6a1c762ab877886cf82724"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#aeb7e6309fe6a1c762ab877886cf82724">proc_save_caller</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p)</td></tr>
<tr class="memdesc:aeb7e6309fe6a1c762ab877886cf82724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current caller's reply cap. This should only be called when the current reply cap is for a message fro mthe given process.  <a href="process_8h.html#aeb7e6309fe6a1c762ab877886cf82724">More...</a><br /></td></tr>
<tr class="separator:aeb7e6309fe6a1c762ab877886cf82724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5a6667058f0b143b875a954ae26b9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#ace5a6667058f0b143b875a954ae26b9e">proc_clone</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p, int *threadID, <a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a> stackAddr, <a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a> entryPoint)</td></tr>
<tr class="memdesc:ace5a6667058f0b143b875a954ae26b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create another thread for the given process, sharing the process' address space.  <a href="process_8h.html#ace5a6667058f0b143b875a954ae26b9e">More...</a><br /></td></tr>
<tr class="separator:ace5a6667058f0b143b875a954ae26b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8955c53667d7360a55a6cb4a8e2bac35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a8955c53667d7360a55a6cb4a8e2bac35">proc_fault_reply</a> (struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *p)</td></tr>
<tr class="memdesc:a8955c53667d7360a55a6cb4a8e2bac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reply to the saved cap previous saved by <a class="el" href="process_8h.html#aeb7e6309fe6a1c762ab877886cf82724" title="Save the current caller&#39;s reply cap. This should only be called when the current reply cap is for a m...">proc_save_caller()</a>.  <a href="process_8h.html#a8955c53667d7360a55a6cb4a8e2bac35">More...</a><br /></td></tr>
<tr class="separator:a8955c53667d7360a55a6cb4a8e2bac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696b07bb3c46870b9e35f913b515eded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process_8h.html#a696b07bb3c46870b9e35f913b515eded">proc_syscall_postaction</a> (void)</td></tr>
<tr class="memdesc:a696b07bb3c46870b9e35f913b515eded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any process book-kepping postactions.  <a href="process_8h.html#a696b07bb3c46870b9e35f913b515eded">More...</a><br /></td></tr>
<tr class="separator:a696b07bb3c46870b9e35f913b515eded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Process management module for process server. </p>
<p>Module which manages everything to do with a process and its threads; provides a basic process interface, handling the virtual memory address spaces, kernel objects, ELF-loading....etc. The sel4utils library is used here to easily implement direct booting of executables. The process server needs to be able to directly boot the system executables needed for the selfloader to function. The selfloader app then takes over the job of ELF-loading RefOS user-land apps once the system is up and running.</p>
<p>Executable files are stored on the process server's own CPIO archive. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a659202ebb2150def5660572a3259aacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659202ebb2150def5660572a3259aacf">&#9670;&nbsp;</a></span>PROCESS_PERMISSION_DEVICE_IOPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROCESS_PERMISSION_DEVICE_IOPORT&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4530a640ac0e101963c9c6684a5f02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4530a640ac0e101963c9c6684a5f02e">&#9670;&nbsp;</a></span>PROCESS_PERMISSION_DEVICE_IRQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROCESS_PERMISSION_DEVICE_IRQ&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24a16df8f836baf66dadfbf7f931f809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a16df8f836baf66dadfbf7f931f809">&#9670;&nbsp;</a></span>PROCESS_PERMISSION_DEVICE_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROCESS_PERMISSION_DEVICE_MAP&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4380c6c2dbdf96c0fda83545d94beaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4380c6c2dbdf96c0fda83545d94beaad">&#9670;&nbsp;</a></span>REFOS_PCB_DEBUGNAME_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFOS_PCB_DEBUGNAME_LEN&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3270c8e6928a8be1b271a39dbf3a4db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3270c8e6928a8be1b271a39dbf3a4db4">&#9670;&nbsp;</a></span>REFOS_PCB_MAGIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFOS_PCB_MAGIC&#160;&#160;&#160;0xB33FFEED</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ace5a6667058f0b143b875a954ae26b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5a6667058f0b143b875a954ae26b9e">&#9670;&nbsp;</a></span>proc_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int proc_clone </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a>&#160;</td>
          <td class="paramname"><em>stackAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a>&#160;</td>
          <td class="paramname"><em>entryPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create another thread for the given process, sharing the process' address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to clone another thread for. </td></tr>
    <tr><td class="paramname">threadID</td><td>Optional output pointer to store the created threadID in. </td></tr>
    <tr><td class="paramname">stackAddr</td><td>The stack address of the new thread, in the given process' vspace. </td></tr>
    <tr><td class="paramname">entryPoint</td><td>The entry point of the new thread, in the given process' vspace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a545b9250f16d07300f38e88fc792a40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545b9250f16d07300f38e88fc792a40a">&#9670;&nbsp;</a></span>proc_config_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int proc_config_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>imageName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>systemCapabilitiesMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up and configure a process. </p>
<p>Set up and configure a process. Note that this does <b>not</b> set up the process's environment to be a RefOS client environment, not does it allocate any new processes. It simply configures the process to use its vspace and loads its ELF regions into the vspace.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to configure (No ownership). </td></tr>
    <tr><td class="paramname">pid</td><td>The allocated PID of the process. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority that the process runs at. </td></tr>
    <tr><td class="paramname">imageName</td><td>The ELF file name, in the process server's CPIO archive. </td></tr>
    <tr><td class="paramname">systemCapabilitiesMask</td><td>The system capabilities mask, which allows access to additional syscalls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a56582b3cfefbbdaed5c74d9cab6fe60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56582b3cfefbbdaed5c74d9cab6fe60a">&#9670;&nbsp;</a></span>proc_dspace_delete_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_dspace_delete_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Purge all references to a dataspace. </p>
<p>Purge all references to a dataspace (called on dataspace deletion). This will unset any parameter or notification buffers that have been set to that dataspace. This is to be used with the <a class="el" href="pid_8c.html#a3a8d18b710500753fd8333f7e820fc14" title="Iterate through all valid PIDs, and invoke the iteration callback.">pid_iterate()</a> function in &lt;<a class="el" href="pid_8h.html" title="Process server PID allocation.">process/pid.h</a>&gt;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process check and unset and dataspace from. </td></tr>
    <tr><td class="paramname">cookie</td><td>The dataspace ID to purge all references to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8955c53667d7360a55a6cb4a8e2bac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8955c53667d7360a55a6cb4a8e2bac35">&#9670;&nbsp;</a></span>proc_fault_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_fault_reply </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reply to the saved cap previous saved by <a class="el" href="process_8h.html#aeb7e6309fe6a1c762ab877886cf82724" title="Save the current caller&#39;s reply cap. This should only be called when the current reply cap is for a m...">proc_save_caller()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to reply to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1123288e3ffe218e7da3d5773d815fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1123288e3ffe218e7da3d5773d815fe">&#9670;&nbsp;</a></span>proc_get_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structproc__tcb.html">proc_tcb</a>* proc_get_thread </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread TCB of process at the given threadID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to get TCB from. </td></tr>
    <tr><td class="paramname">tindex</td><td>The thread index to of the thread TCB to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCB at the given threadID of the given process. (No ownership transfer) </dd></dl>

</div>
</div>
<a id="a471a33059ac7950175d1568e2ef9cf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471a33059ac7950175d1568e2ef9cf53">&#9670;&nbsp;</a></span>proc_load_direct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int proc_load_direct </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>parentPID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>systemCapabilitiesMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly load an ELF into a process. </p>
<p>This function does everything a process needs to run and runs it. It allocates a PID, creates a vspace, loads the ELF segments into it, creates an initial thread, and starts it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The ELF file name, in the process server's CPIO archive. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the initial thread of the process to load. </td></tr>
    <tr><td class="paramname">param</td><td>The static parameter to give to the process. </td></tr>
    <tr><td class="paramname">parentPID</td><td>The PId of the parent that has started this process. </td></tr>
    <tr><td class="paramname">systemCapabilitiesMask</td><td>The system capabilities mask, which allows access to additional syscalls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="af95532e638ce424d70b91b5509541918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95532e638ce424d70b91b5509541918">&#9670;&nbsp;</a></span>proc_nice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int proc_nice </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the priority for a given process' thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to change priority for. </td></tr>
    <tr><td class="paramname">tindex</td><td>The thread index to change priority for. </td></tr>
    <tr><td class="paramname">priority</td><td>The new priority to change to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="ad3dc33fc12015bdaa41a9ae60770a789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dc33fc12015bdaa41a9ae60770a789">&#9670;&nbsp;</a></span>proc_queue_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_queue_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues a process to be released at the next <a class="el" href="process_8h.html#a696b07bb3c46870b9e35f913b515eded" title="Perform any process book-kepping postactions.">proc_syscall_postaction()</a> call. </p>
<p>This is done to avoid leaving IPC state inconsistent. See <a class="el" href="process_8h.html#a5b752c4db755479adeeae57a5e982418" title="Release a process, and delete all its owned resources.">proc_release()</a> documentation for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to queue for release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b752c4db755479adeeae57a5e982418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b752c4db755479adeeae57a5e982418">&#9670;&nbsp;</a></span>proc_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a process, and delete all its owned resources. </p>
<p>This function destroys a process and deletes everything that it has ownership to. Note that the actual vspace may not be destroyed, as it could have more shared references. When a client process exit call is recieved, do <b>NOT</b> use this function, as we are not able to clean up the IPC state mid-way through an IPC. Instead, handle the IPC state properly, skipping replying to block the client, and use <a class="el" href="process_8h.html#ad3dc33fc12015bdaa41a9ae60770a789" title="Queues a process to be released at the next proc_syscall_postaction() call.">proc_queue_release()</a> instead to release the client once the IPC is over.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb7e6309fe6a1c762ab877886cf82724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7e6309fe6a1c762ab877886cf82724">&#9670;&nbsp;</a></span>proc_save_caller()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int proc_save_caller </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the current caller's reply cap. This should only be called when the current reply cap is for a message fro mthe given process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to save current caller cap into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a775dc91d0609d182f8c83fdfb7c40b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775dc91d0609d182f8c83fdfb7c40b18">&#9670;&nbsp;</a></span>proc_set_notificationbuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int proc_set_notificationbuffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structram__dspace.html">ram_dspace</a> *&#160;</td>
          <td class="paramname"><em>notifBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the async notification buffer for a process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to set notification buffer for. </td></tr>
    <tr><td class="paramname">notifBuffer</td><td>The notification buffer anon dataspace structure. (Shared ownership) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="aa9267fe695f757ab014803103524bef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9267fe695f757ab014803103524bef7">&#9670;&nbsp;</a></span>proc_set_parambuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_set_parambuffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structram__dspace.html">ram_dspace</a> *&#160;</td>
          <td class="paramname"><em>paramBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the parameter buffer for a process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to set parameter buffer for. </td></tr>
    <tr><td class="paramname">paramBuffer</td><td>The parameter buffer anon dataspace structure. (Shared ownership) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a86fd694f51d9da8312851ab2ec5fbe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fd694f51d9da8312851ab2ec5fbe4a">&#9670;&nbsp;</a></span>proc_start_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int proc_start_thread </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a process' thread running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The process to start. </td></tr>
    <tr><td class="paramname">tindex</td><td>The index of the thread to start in given process. </td></tr>
    <tr><td class="paramname">arg0</td><td>The first argument to pass to the thread's entry point. (unimplemented) </td></tr>
    <tr><td class="paramname">arg1</td><td>The second argument to pass to the thread's entry point. (unimplemented) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a696b07bb3c46870b9e35f913b515eded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696b07bb3c46870b9e35f913b515eded">&#9670;&nbsp;</a></span>proc_syscall_postaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_syscall_postaction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform any process book-kepping postactions. </p>
<p>This is used to neatly release an exiting process, without leaving an inconsistent IPC state. See the documentation under <a class="el" href="process_8h.html#a5b752c4db755479adeeae57a5e982418" title="Release a process, and delete all its owned resources.">proc_release()</a> for details. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_9654b8d08f4bba4e84b362c5fd320bee.html">apps</a></li><li class="navelem"><a class="el" href="dir_53aa6d20d2a83f4c89c1fd34dd1fa489.html">process_server</a></li><li class="navelem"><a class="el" href="dir_2020bcb30412175c6238bd50c5604389.html">src</a></li><li class="navelem"><a class="el" href="dir_88a707bee8654bad827f225accdc13fe.html">system</a></li><li class="navelem"><a class="el" href="dir_0740f6be5d791db3eb5e0100e23c5632.html">process</a></li><li class="navelem"><a class="el" href="process_8h.html">process.h</a></li>
    <li class="footer">Generated on Sat Jun 10 2023 10:14:24 for RefOS by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
