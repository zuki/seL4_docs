<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RefOS: apps/process_server/src/system/addrspace/vspace.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="header-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RefOS
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Multi-server operating system on seL4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('vspace_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vspace.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Client address space objects.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="stdio_8h_source.html">stdio.h</a>&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;<a class="el" href="cvector_8h_source.html">data_struct/cvector.h</a>&gt;</code><br />
<code>#include &lt;allocman/allocman.h&gt;</code><br />
<code>#include &lt;allocman/vka.h&gt;</code><br />
<code>#include &lt;sel4utils/util.h&gt;</code><br />
<code>#include &lt;sel4utils/vspace.h&gt;</code><br />
<code>#include &quot;<a class="el" href="common_8h_source.html">../../common.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="window_8h_source.html">../memserv/window.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pagedir_8h_source.html">pagedir.h</a>&quot;</code><br />
</div>
<p><a href="vspace_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvs__vspace.html">vs_vspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Client VSpace structure. Each process is assigned one.  <a href="structvs__vspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab38e3a6d9de2e69f440b2993f42c83ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#ab38e3a6d9de2e69f440b2993f42c83ab">REFOS_VSPACE_MAGIC</a>&#160;&#160;&#160;0x03FFED14</td></tr>
<tr class="separator:ab38e3a6d9de2e69f440b2993f42c83ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab810071185364e7fcbd975eb2cdea70f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#ab810071185364e7fcbd975eb2cdea70f">vs_initialise</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs, uint32_t pid)</td></tr>
<tr class="memdesc:ab810071185364e7fcbd975eb2cdea70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a VSpace structure.  <a href="vspace_8h.html#ab810071185364e7fcbd975eb2cdea70f">More...</a><br /></td></tr>
<tr class="separator:ab810071185364e7fcbd975eb2cdea70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00be7ff92cb53f8d1045b404cfb410b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#ad00be7ff92cb53f8d1045b404cfb410b">vs_ref</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs)</td></tr>
<tr class="memdesc:ad00be7ff92cb53f8d1045b404cfb410b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a shared reference to the VSpaces' reference count.  <a href="vspace_8h.html#ad00be7ff92cb53f8d1045b404cfb410b">More...</a><br /></td></tr>
<tr class="separator:ad00be7ff92cb53f8d1045b404cfb410b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a16eaba97b45e951db40cb40584f99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#a07a16eaba97b45e951db40cb40584f99">vs_unref</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs)</td></tr>
<tr class="memdesc:a07a16eaba97b45e951db40cb40584f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a shared reference to the VSpaces' reference count. If this is the last reference to a vspace, then it is deleted and the underlying vspace deleted.  <a href="vspace_8h.html#a07a16eaba97b45e951db40cb40584f99">More...</a><br /></td></tr>
<tr class="separator:a07a16eaba97b45e951db40cb40584f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1531d782785f205acb1b0a29ce9beece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#a1531d782785f205acb1b0a29ce9beece">vs_track_obj</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs, vka_object_t <a class="el" href="structobject.html">object</a>)</td></tr>
<tr class="memdesc:a1531d782785f205acb1b0a29ce9beece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add tracked kernel VKA object to be owned by this vspace. The VKA object will be deleted when the vspace is deleted.  <a href="vspace_8h.html#a1531d782785f205acb1b0a29ce9beece">More...</a><br /></td></tr>
<tr class="separator:a1531d782785f205acb1b0a29ce9beece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc81e92adb8e64d57fc1ffc3b71365f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#adc81e92adb8e64d57fc1ffc3b71365f1">vs_create_window</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs, <a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a> vaddr, <a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a> size, seL4_Word permissions, bool cacheable, int *winID)</td></tr>
<tr class="memdesc:adc81e92adb8e64d57fc1ffc3b71365f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a memory segment window in this vspace.  <a href="vspace_8h.html#adc81e92adb8e64d57fc1ffc3b71365f1">More...</a><br /></td></tr>
<tr class="separator:adc81e92adb8e64d57fc1ffc3b71365f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4a4d42b4efaf412dc609db42cf70c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#a9a4a4d42b4efaf412dc609db42cf70c4">vs_delete_window</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs, int wID)</td></tr>
<tr class="memdesc:a9a4a4d42b4efaf412dc609db42cf70c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a memory segment window in this vspace.  <a href="vspace_8h.html#a9a4a4d42b4efaf412dc609db42cf70c4">More...</a><br /></td></tr>
<tr class="separator:a9a4a4d42b4efaf412dc609db42cf70c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa21b9b1e3cfc02f78542172c664e84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#acaa21b9b1e3cfc02f78542172c664e84">vs_resize_window</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs, int wID, <a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a> size)</td></tr>
<tr class="memdesc:acaa21b9b1e3cfc02f78542172c664e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a memory segment window in this vspace.  <a href="vspace_8h.html#acaa21b9b1e3cfc02f78542172c664e84">More...</a><br /></td></tr>
<tr class="separator:acaa21b9b1e3cfc02f78542172c664e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8411c54b9268006b8c16ea9504f716d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#a8411c54b9268006b8c16ea9504f716d6">vs_map</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs, <a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a> vaddr, seL4_CPtr frames[], int nFrames)</td></tr>
<tr class="memdesc:a8411c54b9268006b8c16ea9504f716d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an array of frames into vspace. Needs a valid window to be covering that address range.  <a href="vspace_8h.html#a8411c54b9268006b8c16ea9504f716d6">More...</a><br /></td></tr>
<tr class="separator:a8411c54b9268006b8c16ea9504f716d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2974a17841b837927b9f05e285ac6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#acb2974a17841b837927b9f05e285ac6b">vs_map_across_vspace</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vsSrc, <a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a> vaddrSrc, struct <a class="el" href="structw__window.html">w_window</a> *windowDest, uint32_t windowDestOffset, struct <a class="el" href="structproc__pcb.html">proc_pcb</a> **outClientPCB)</td></tr>
<tr class="memdesc:acb2974a17841b837927b9f05e285ac6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an array of frames that have been mapped into one vspace, into another vspace.  <a href="vspace_8h.html#acb2974a17841b837927b9f05e285ac6b">More...</a><br /></td></tr>
<tr class="separator:acb2974a17841b837927b9f05e285ac6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb9b18cffcb1783945d90f011b5a961"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#a1bb9b18cffcb1783945d90f011b5a961">vs_map_device</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs, struct <a class="el" href="structw__window.html">w_window</a> *window, uint32_t windowOffset, uint32_t paddr, uint32_t size, bool cached)</td></tr>
<tr class="memdesc:a1bb9b18cffcb1783945d90f011b5a961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find &amp; map a device frame into client's vspace.  <a href="vspace_8h.html#a1bb9b18cffcb1783945d90f011b5a961">More...</a><br /></td></tr>
<tr class="separator:a1bb9b18cffcb1783945d90f011b5a961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5dc0a9565cade759bbf35b95ac3aac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#a3d5dc0a9565cade759bbf35b95ac3aac">vs_unmap</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs, <a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a> vaddr, int nFrames)</td></tr>
<tr class="memdesc:a3d5dc0a9565cade759bbf35b95ac3aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap a series of frames from vspace. Needs a valid window to be covering that address range.  <a href="vspace_8h.html#a3d5dc0a9565cade759bbf35b95ac3aac">More...</a><br /></td></tr>
<tr class="separator:a3d5dc0a9565cade759bbf35b95ac3aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f172d5df3de973b07118b3465794595"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#a9f172d5df3de973b07118b3465794595">vs_unmap_window</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs, int wID)</td></tr>
<tr class="memdesc:a9f172d5df3de973b07118b3465794595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap the frames covered by given window, in a vspace.  <a href="vspace_8h.html#a9f172d5df3de973b07118b3465794595">More...</a><br /></td></tr>
<tr class="separator:a9f172d5df3de973b07118b3465794595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ba1b56f1a145430e914b065ecf7976"><td class="memItemLeft" align="right" valign="top">cspacepath_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vspace_8h.html#a01ba1b56f1a145430e914b065ecf7976">vs_get_frame</a> (struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *vs, <a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a> vaddr)</td></tr>
<tr class="memdesc:a01ba1b56f1a145430e914b065ecf7976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the frame mapped in a vaddr, if any.  <a href="vspace_8h.html#a01ba1b56f1a145430e914b065ecf7976">More...</a><br /></td></tr>
<tr class="separator:a01ba1b56f1a145430e914b065ecf7976"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Client address space objects. </p>
<p>This module is responsible for managing a client's vspace (and cspace included). Exposes memory segment window management, mapping &amp; unmapping, along with seL4utils reservations. <a class="el" href="structvs__vspace.html" title="Client VSpace structure. Each process is assigned one.">vs_vspace</a> structures do not actually own the kernel PD / root CNode objects they wrap, they are owned by the PD. Also does not allocate ow deallocated the vspace's associated PIDs. VSpace objects support shared strong references through refcounting. This is done mostly to support COW (copy- on-write) of vspaces. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab38e3a6d9de2e69f440b2993f42c83ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38e3a6d9de2e69f440b2993f42c83ab">&#9670;&nbsp;</a></span>REFOS_VSPACE_MAGIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFOS_VSPACE_MAGIC&#160;&#160;&#160;0x03FFED14</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adc81e92adb8e64d57fc1ffc3b71365f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc81e92adb8e64d57fc1ffc3b71365f1">&#9670;&nbsp;</a></span>vs_create_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vs_create_window </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a>&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">seL4_Word&#160;</td>
          <td class="paramname"><em>permissions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cacheable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>winID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a memory segment window in this vspace. </p>
<p>A wrapper / helper fucntion which creates a global window object, associates it with this vspace, and creates the sel4utils reservation. When managing a client's memory, these window management functions should be used instead of the lower level functions in the &lt;<a class="el" href="window_8h.html" title="Manages and keeps track of memory windows.">memserv/window.h</a>&gt; module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The vspace to create a memory segment window in. </td></tr>
    <tr><td class="paramname">vaddr</td><td>The vaddr where the memory segment window starts. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the memory segment to create. </td></tr>
    <tr><td class="paramname">permissions</td><td>Permissions flags bitmask. (W_PERMISSION_WRITE / W_PERMISSION_READ) </td></tr>
    <tr><td class="paramname">cacheable</td><td>Whether this memory segment is cacheable. </td></tr>
    <tr><td class="paramname">winID</td><td>Optional output containing the ID of window assigned to the created segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a9a4a4d42b4efaf412dc609db42cf70c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4a4d42b4efaf412dc609db42cf70c4">&#9670;&nbsp;</a></span>vs_delete_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vs_delete_window </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a memory segment window in this vspace. </p>
<p>A wrapper / helper function which unmaps the segment region, unassociated and deletes the window object. When managing a client's memory, these window management functions should be used instead of the lower level functions in the &lt;<a class="el" href="window_8h.html" title="Manages and keeps track of memory windows.">memserv/window.h</a>&gt; module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The vspace to delete given memory segment window in. </td></tr>
    <tr><td class="paramname">wID</td><td>The windowID of window to delete. This window should belong in the vspace given. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01ba1b56f1a145430e914b065ecf7976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ba1b56f1a145430e914b065ecf7976">&#9670;&nbsp;</a></span>vs_get_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cspacepath_t vs_get_frame </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a>&#160;</td>
          <td class="paramname"><em>vaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the frame mapped in a vaddr, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The vspace to get mapped from. </td></tr>
    <tr><td class="paramname">vaddr</td><td>The vaddr to get map from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mapped from, if any. </dd></dl>

</div>
</div>
<a id="ab810071185364e7fcbd975eb2cdea70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab810071185364e7fcbd975eb2cdea70f">&#9670;&nbsp;</a></span>vs_initialise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vs_initialise </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a VSpace structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The VSpace structure to intialise (No ownership) </td></tr>
    <tr><td class="paramname">pid</td><td>The allocated unique PID to assign this vspace to. Each process has exactly one addrspace, so the ASID is the PID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS if success, refos-err_t otherwise. </dd></dl>

</div>
</div>
<a id="a8411c54b9268006b8c16ea9504f716d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8411c54b9268006b8c16ea9504f716d6">&#9670;&nbsp;</a></span>vs_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vs_map </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a>&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">seL4_CPtr&#160;</td>
          <td class="paramname"><em>frames</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFrames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map an array of frames into vspace. Needs a valid window to be covering that address range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The vspace to map frames into. </td></tr>
    <tr><td class="paramname">vaddr</td><td>The starting destination vaddr into vspace to map frames into. </td></tr>
    <tr><td class="paramname">frames</td><td>Array of frames to map. </td></tr>
    <tr><td class="paramname">nFrames</td><td>Number of frames in given frame array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="acb2974a17841b837927b9f05e285ac6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2974a17841b837927b9f05e285ac6b">&#9670;&nbsp;</a></span>vs_map_across_vspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vs_map_across_vspace </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vsSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a>&#160;</td>
          <td class="paramname"><em>vaddrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structw__window.html">w_window</a> *&#160;</td>
          <td class="paramname"><em>windowDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>windowDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structproc__pcb.html">proc_pcb</a> **&#160;</td>
          <td class="paramname"><em>outClientPCB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map an array of frames that have been mapped into one vspace, into another vspace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsSrc</td><td>The source vspace to map from. </td></tr>
    <tr><td class="paramname">vaddrSrc</td><td>The vaddr in the source vspace to map from. </td></tr>
    <tr><td class="paramname">windowDest</td><td>Destination window to map into. </td></tr>
    <tr><td class="paramname">windowDestOffset</td><td>Offset into destination window. </td></tr>
    <tr><td class="paramname">outClientPCB</td><td>Optional destination client PCB which uses this vspace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a1bb9b18cffcb1783945d90f011b5a961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb9b18cffcb1783945d90f011b5a961">&#9670;&nbsp;</a></span>vs_map_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vs_map_device </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structw__window.html">w_window</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>windowOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>paddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cached</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find &amp; map a device frame into client's vspace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The vspace to map device frame into. </td></tr>
    <tr><td class="paramname">window</td><td>The window in which to map the device. </td></tr>
    <tr><td class="paramname">windowOffset</td><td>Offset into the window at which the device frame(s) will be mapped. </td></tr>
    <tr><td class="paramname">paddr</td><td>The physical address of the device to map. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the device frames. </td></tr>
    <tr><td class="paramname">cached</td><td>Whether to map the device frame cached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="ad00be7ff92cb53f8d1045b404cfb410b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00be7ff92cb53f8d1045b404cfb410b">&#9670;&nbsp;</a></span>vs_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vs_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a shared reference to the VSpaces' reference count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The valid vspace to add a shared reference to. (No ownership) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaa21b9b1e3cfc02f78542172c664e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa21b9b1e3cfc02f78542172c664e84">&#9670;&nbsp;</a></span>vs_resize_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vs_resize_window </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a memory segment window in this vspace. </p>
<p>A wrapper / helper function which resizes a memory segment. Currently, window shrinking is not supported yet, only expanding. When managing a client's memory, these window management functions should be used instead of the lower level functions in the &lt;<a class="el" href="window_8h.html" title="Manages and keeps track of memory windows.">memserv/window.h</a>&gt; module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The vspace to resize given memory segment window in. </td></tr>
    <tr><td class="paramname">wID</td><td>The windowID of window to resize. This window should belong in the vspace given. </td></tr>
    <tr><td class="paramname">size</td><td>The new window segment size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a1531d782785f205acb1b0a29ce9beece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1531d782785f205acb1b0a29ce9beece">&#9670;&nbsp;</a></span>vs_track_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vs_track_obj </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vka_object_t&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add tracked kernel VKA object to be owned by this vspace. The VKA object will be deleted when the vspace is deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The valid vspace to add a tracked object to. </td></tr>
    <tr><td class="paramname">object</td><td>The VKA object to add to the vspaces' ownership (Takes ownership). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d5dc0a9565cade759bbf35b95ac3aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5dc0a9565cade759bbf35b95ac3aac">&#9670;&nbsp;</a></span>vs_unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vs_unmap </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pager_8h.html#a7d72eb642e1a38d355db6a57460d5973">vaddr_t</a>&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFrames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmap a series of frames from vspace. Needs a valid window to be covering that address range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The vspace to unmap frames from. </td></tr>
    <tr><td class="paramname">vaddr</td><td>The vaddr to unmap frames from. </td></tr>
    <tr><td class="paramname">nFrames</td><td>The number of 4k frames from given vaddr to unmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ESUCCESS on success, refos_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a9f172d5df3de973b07118b3465794595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f172d5df3de973b07118b3465794595">&#9670;&nbsp;</a></span>vs_unmap_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vs_unmap_window </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmap the frames covered by given window, in a vspace. </p>
<p>Unmap the frames covered by given window, in a vspace. Note that this does not do anything to the actual window (doesn't unassociate the window nor deletes the window). It merely unmaps the frames under it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The vspace to unmap window from. </td></tr>
    <tr><td class="paramname">wID</td><td>The windowID of the window to unmap frames under. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07a16eaba97b45e951db40cb40584f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a16eaba97b45e951db40cb40584f99">&#9670;&nbsp;</a></span>vs_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vs_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structvs__vspace.html">vs_vspace</a> *&#160;</td>
          <td class="paramname"><em>vs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a shared reference to the VSpaces' reference count. If this is the last reference to a vspace, then it is deleted and the underlying vspace deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>The valid vspace to add a shared reference to. (Takes ownership) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_9654b8d08f4bba4e84b362c5fd320bee.html">apps</a></li><li class="navelem"><a class="el" href="dir_53aa6d20d2a83f4c89c1fd34dd1fa489.html">process_server</a></li><li class="navelem"><a class="el" href="dir_2020bcb30412175c6238bd50c5604389.html">src</a></li><li class="navelem"><a class="el" href="dir_88a707bee8654bad827f225accdc13fe.html">system</a></li><li class="navelem"><a class="el" href="dir_7c9037346a8207f935e4bd967ad01401.html">addrspace</a></li><li class="navelem"><a class="el" href="vspace_8h.html">vspace.h</a></li>
    <li class="footer">Generated on Sat Jun 10 2023 10:14:24 for RefOS by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
