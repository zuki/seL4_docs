<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RefOS: libs/librefos/include/refos-rpc/rpc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="header-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RefOS
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Multi-server operating system on seL4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('rpc_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rpc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>seL4 CIDL RPC Backend Interface  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="stdio_8h_source.html">stdio.h</a>&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;sel4/sel4.h&gt;</code><br />
</div>
<p><a href="rpc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpc__client__state__s.html">rpc_client_state_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpc__buffer__s.html">rpc_buffer_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a631c4a678dabae1c8a0fc1b68b167430"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a631c4a678dabae1c8a0fc1b68b167430">RPC_MAX_TRACKED_OBJS</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a631c4a678dabae1c8a0fc1b68b167430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b04822aa4462f2a63da3b43c9cfd96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a66b04822aa4462f2a63da3b43c9cfd96">_SEL4_</a></td></tr>
<tr class="separator:a66b04822aa4462f2a63da3b43c9cfd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fe238ddd149399555edc5f291dc58d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a>&#160;&#160;&#160;seL4_CPtr</td></tr>
<tr class="separator:ac2fe238ddd149399555edc5f291dc58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2b7e7856b48ec3327148ac994ad95cd5"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a2b7e7856b48ec3327148ac994ad95cd5">byte</a></td></tr>
<tr class="separator:a2b7e7856b48ec3327148ac994ad95cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123f0d890b66b46d828310dd40651a9c"><td class="memItemLeft" align="right" valign="top">typedef seL4_CPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a123f0d890b66b46d828310dd40651a9c">cptr</a></td></tr>
<tr class="separator:a123f0d890b66b46d828310dd40651a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff283406e5bd55d19158ac73d498fc1f"><td class="memItemLeft" align="right" valign="top">typedef seL4_CPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#aff283406e5bd55d19158ac73d498fc1f">cslot</a></td></tr>
<tr class="separator:aff283406e5bd55d19158ac73d498fc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d64c94011f903c5eda8c2aba5fdbf1"><td class="memItemLeft" align="right" valign="top">typedef seL4_CPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a24d64c94011f903c5eda8c2aba5fdbf1">seL4_CSlot</a></td></tr>
<tr class="separator:a24d64c94011f903c5eda8c2aba5fdbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244302783b8b96fc566af41ea3a8270a"><td class="memItemLeft" align="right" valign="top">typedef seL4_MessageInfo_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a244302783b8b96fc566af41ea3a8270a">msginfo_t</a></td></tr>
<tr class="separator:a244302783b8b96fc566af41ea3a8270a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d247c3b6e4667192eaad5e6f7649b5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrpc__client__state__s.html">rpc_client_state_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a79d247c3b6e4667192eaad5e6f7649b5">rpc_client_state_t</a></td></tr>
<tr class="separator:a79d247c3b6e4667192eaad5e6f7649b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432b131f8da6c189061eed2edb768581"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrpc__buffer__s.html">rpc_buffer_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a432b131f8da6c189061eed2edb768581">rpc_buffer_t</a></td></tr>
<tr class="separator:a432b131f8da6c189061eed2edb768581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1ba5faebcc6de15dbe556d0962c794a3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a1ba5faebcc6de15dbe556d0962c794a3">rpc_malloc</a> (size_t sz)</td></tr>
<tr class="separator:a1ba5faebcc6de15dbe556d0962c794a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00da1d638d4ac11a9ca02ddfe797e323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a00da1d638d4ac11a9ca02ddfe797e323">rpc_free</a> (void *addr)</td></tr>
<tr class="separator:a00da1d638d4ac11a9ca02ddfe797e323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c85e176e6dd23cc5ae050cd32f49971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a4c85e176e6dd23cc5ae050cd32f49971">rpc_setup_recv</a> (<a class="el" href="rpc_8h.html#aff283406e5bd55d19158ac73d498fc1f">cslot</a> recv_cslot)</td></tr>
<tr class="separator:a4c85e176e6dd23cc5ae050cd32f49971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3ab7b09834f82b466a07e2b309dbad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a5f3ab7b09834f82b466a07e2b309dbad">rpc_setup_recv_cspace</a> (seL4_CPtr cspace, seL4_CPtr recv_cslot, seL4_Word depth)</td></tr>
<tr class="separator:a5f3ab7b09834f82b466a07e2b309dbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0231178aaf29570b84ef4cf65aebf5c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a0231178aaf29570b84ef4cf65aebf5c7">rpc_reset_contents</a> (void *cl)</td></tr>
<tr class="separator:a0231178aaf29570b84ef4cf65aebf5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f74ad32a1e217937df9ed512847e5da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a7f74ad32a1e217937df9ed512847e5da">rpc_init</a> (<a class="el" href="tradstdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name_str, int32_t label)</td></tr>
<tr class="separator:a7f74ad32a1e217937df9ed512847e5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a11e004e4e8f5228ba37f9bb51186c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a4a11e004e4e8f5228ba37f9bb51186c5">rpc_set_dest</a> (<a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a> dest)</td></tr>
<tr class="separator:a4a11e004e4e8f5228ba37f9bb51186c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7daffff567cae2d89516946caa8981fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a7daffff567cae2d89516946caa8981fd">rpc_push_uint</a> (uint32_t v)</td></tr>
<tr class="separator:a7daffff567cae2d89516946caa8981fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f50c90705ab9cf1affb1ddd7dd368d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a80f50c90705ab9cf1affb1ddd7dd368d">rpc_push_str</a> (<a class="el" href="tradstdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *v)</td></tr>
<tr class="separator:a80f50c90705ab9cf1affb1ddd7dd368d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25315d6b4c5b0d16d49fc62a1a7f2029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a25315d6b4c5b0d16d49fc62a1a7f2029">rpc_push_buf</a> (void *v, size_t sz)</td></tr>
<tr class="separator:a25315d6b4c5b0d16d49fc62a1a7f2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acf893243f2d8cacdebec0bfcdcb805"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a6acf893243f2d8cacdebec0bfcdcb805">rpc_push_buf_array</a> (void *v, size_t sz, uint32_t count)</td></tr>
<tr class="separator:a6acf893243f2d8cacdebec0bfcdcb805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37573ea2f169dec545d9baf39b1817f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#ac37573ea2f169dec545d9baf39b1817f">rpc_push_cptr</a> (<a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a> v)</td></tr>
<tr class="separator:ac37573ea2f169dec545d9baf39b1817f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea605785377d97fdd9c075d81c5cf7c9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#aea605785377d97fdd9c075d81c5cf7c9">rpc_pop_uint</a> ()</td></tr>
<tr class="separator:aea605785377d97fdd9c075d81c5cf7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4e8bc6b8d64ed0746a732bc162116f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a1b4e8bc6b8d64ed0746a732bc162116f">rpc_pop_str</a> (char *v)</td></tr>
<tr class="separator:a1b4e8bc6b8d64ed0746a732bc162116f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b1c202902aba304be2e5efc10f2a99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#ae6b1c202902aba304be2e5efc10f2a99">rpc_pop_buf</a> (void *v, size_t sz)</td></tr>
<tr class="separator:ae6b1c202902aba304be2e5efc10f2a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e46915864f9c8818a4883c0488a760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a14e46915864f9c8818a4883c0488a760">rpc_pop_cptr</a> ()</td></tr>
<tr class="separator:a14e46915864f9c8818a4883c0488a760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1f4220191c751b7ee4de8f826a401b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#acf1f4220191c751b7ee4de8f826a401b">rpc_pop_buf_array</a> (void *v, size_t sz, uint32_t count)</td></tr>
<tr class="separator:acf1f4220191c751b7ee4de8f826a401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb766fe0c62d1e62b33d3b23d441bb56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#afb766fe0c62d1e62b33d3b23d441bb56">rpc_call_server</a> ()</td></tr>
<tr class="separator:afb766fe0c62d1e62b33d3b23d441bb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b7a3ec607ccb55ff1e0a667f2047f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a53b7a3ec607ccb55ff1e0a667f2047f1">rpc_release</a> ()</td></tr>
<tr class="separator:a53b7a3ec607ccb55ff1e0a667f2047f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1ff8159a2e2610fe0e3c031167ffe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#afd1ff8159a2e2610fe0e3c031167ffe5">rpc_copyout_cptr</a> (<a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a> v)</td></tr>
<tr class="separator:afd1ff8159a2e2610fe0e3c031167ffe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c296bc474e8fe39853385adab0d9dee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a6c296bc474e8fe39853385adab0d9dee">rpc_sv_init</a> (void *cl)</td></tr>
<tr class="separator:a6c296bc474e8fe39853385adab0d9dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b648766008f486faa723471e3ec3d95"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a1b648766008f486faa723471e3ec3d95">rpc_sv_pop_uint</a> (void *cl)</td></tr>
<tr class="separator:a1b648766008f486faa723471e3ec3d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69f53755ee46967c62259b75cb72f53"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#aa69f53755ee46967c62259b75cb72f53">rpc_sv_pop_str</a> (void *cl)</td></tr>
<tr class="separator:aa69f53755ee46967c62259b75cb72f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e89da3619f520a53c0fc25d2b4d15ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a7e89da3619f520a53c0fc25d2b4d15ac">rpc_sv_pop_buf</a> (void *cl, void *v, size_t sz)</td></tr>
<tr class="separator:a7e89da3619f520a53c0fc25d2b4d15ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd39c115485186d20a4f2a17d053d385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpc_8h.html#a432b131f8da6c189061eed2edb768581">rpc_buffer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#afd39c115485186d20a4f2a17d053d385">rpc_sv_pop_buf_array</a> (void *cl, size_t sz)</td></tr>
<tr class="separator:afd39c115485186d20a4f2a17d053d385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd125230d672f6101fa5d2a0f34ee0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#aabd125230d672f6101fa5d2a0f34ee0b">rpc_sv_pop_cptr</a> (void *cl)</td></tr>
<tr class="separator:aabd125230d672f6101fa5d2a0f34ee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4844c1ac1b6000e81b63d1da25d0f58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#ac4844c1ac1b6000e81b63d1da25d0f58">rpc_sv_push_uint</a> (void *cl, uint32_t v)</td></tr>
<tr class="separator:ac4844c1ac1b6000e81b63d1da25d0f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bef57f9167df839ca40abf7690704b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a8bef57f9167df839ca40abf7690704b8">rpc_sv_push_buf</a> (void *cl, void *v, size_t sz)</td></tr>
<tr class="separator:a8bef57f9167df839ca40abf7690704b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415ca1ae9aa2312dcae2f682d3b3a08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a415ca1ae9aa2312dcae2f682d3b3a08c">rpc_sv_push_cptr</a> (void *cl, <a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a> v)</td></tr>
<tr class="separator:a415ca1ae9aa2312dcae2f682d3b3a08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4025f75161f7196bdf4285344a37df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a0a4025f75161f7196bdf4285344a37df">rpc_sv_push_buf_array</a> (void *cl, <a class="el" href="rpc_8h.html#a432b131f8da6c189061eed2edb768581">rpc_buffer_t</a> v, size_t sz)</td></tr>
<tr class="separator:a0a4025f75161f7196bdf4285344a37df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef89317c2e6249f857f0a34a72fbe6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#aef89317c2e6249f857f0a34a72fbe6b0">rpc_sv_reply</a> (void *cl)</td></tr>
<tr class="separator:aef89317c2e6249f857f0a34a72fbe6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a992636b31f73aecf3c21171c053b67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a5a992636b31f73aecf3c21171c053b67">rpc_sv_release</a> (void *cl)</td></tr>
<tr class="separator:a5a992636b31f73aecf3c21171c053b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fff57b68be8d696b60c5a9152874b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#ad9fff57b68be8d696b60c5a9152874b6">rpc_sv_save_reply</a> (void *cl)</td></tr>
<tr class="separator:ad9fff57b68be8d696b60c5a9152874b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae906346e779efb2ccf1535a35bb6093c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#ae906346e779efb2ccf1535a35bb6093c">rpc_sv_get_reply_endpoint</a> (void *cl)</td></tr>
<tr class="separator:ae906346e779efb2ccf1535a35bb6093c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1c7c356fc93b95454f9a132e0b6fd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a5a1c7c356fc93b95454f9a132e0b6fd4">rpc_sv_track_obj</a> (void *cl, void *addr)</td></tr>
<tr class="separator:a5a1c7c356fc93b95454f9a132e0b6fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9610abab3174984d910bf32931585ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#ad9610abab3174984d910bf32931585ae">rpc_sv_free_tracked_objs</a> (void *cl)</td></tr>
<tr class="separator:ad9610abab3174984d910bf32931585ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9079d9a7e2b8c9a93163a96226823676"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rpc_8h.html#a9079d9a7e2b8c9a93163a96226823676">rpc_sv_skip_reply</a> (void *cl)</td></tr>
<tr class="separator:a9079d9a7e2b8c9a93163a96226823676"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>seL4 CIDL RPC Backend Interface </p>
<dl class="section date"><dt>Date</dt><dd>Fri 09 Aug 2013 13:00:56 EST</dd></dl>
<p>This library provides the backend which the code generated from CIDL - Simple C IDL compiler uses in order to work. This library must deal with basic serialisation / deserialisation, manage basic client state on server side, and manage the communication channel in between. The CIDL generated code expects this library to be there.</p>
<p>NOTE: All of the implementations here may <em>NOT</em> themselves send RPCs, with few exception. Remember that if your printf involves an IPC to a server, this means no printf unless you use another IPC buffer. Likewise with malloc. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a66b04822aa4462f2a63da3b43c9cfd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b04822aa4462f2a63da3b43c9cfd96">&#9670;&nbsp;</a></span>_SEL4_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SEL4_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2fe238ddd149399555edc5f291dc58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fe238ddd149399555edc5f291dc58d">&#9670;&nbsp;</a></span>ENDPT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPT&#160;&#160;&#160;seL4_CPtr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a631c4a678dabae1c8a0fc1b68b167430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631c4a678dabae1c8a0fc1b68b167430">&#9670;&nbsp;</a></span>RPC_MAX_TRACKED_OBJS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RPC_MAX_TRACKED_OBJS&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of tracked objects for a single RPC call. Shouldn't need to be too long unless you have functions which take a lot of arguments. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2b7e7856b48ec3327148ac994ad95cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7e7856b48ec3327148ac994ad95cd5">&#9670;&nbsp;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="rpc_8h.html#a2b7e7856b48ec3327148ac994ad95cd5">byte</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a123f0d890b66b46d828310dd40651a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123f0d890b66b46d828310dd40651a9c">&#9670;&nbsp;</a></span>cptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef seL4_CPtr <a class="el" href="rpc_8h.html#a123f0d890b66b46d828310dd40651a9c">cptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff283406e5bd55d19158ac73d498fc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff283406e5bd55d19158ac73d498fc1f">&#9670;&nbsp;</a></span>cslot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef seL4_CPtr <a class="el" href="rpc_8h.html#aff283406e5bd55d19158ac73d498fc1f">cslot</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a244302783b8b96fc566af41ea3a8270a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244302783b8b96fc566af41ea3a8270a">&#9670;&nbsp;</a></span>msginfo_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef seL4_MessageInfo_t <a class="el" href="rpc_8h.html#a244302783b8b96fc566af41ea3a8270a">msginfo_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a432b131f8da6c189061eed2edb768581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432b131f8da6c189061eed2edb768581">&#9670;&nbsp;</a></span>rpc_buffer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrpc__buffer__s.html">rpc_buffer_s</a> <a class="el" href="rpc_8h.html#a432b131f8da6c189061eed2edb768581">rpc_buffer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple buffer structure. Buffer array (pointer / length combinations in C) are converted to this on server side. </p>

</div>
</div>
<a id="a79d247c3b6e4667192eaad5e6f7649b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d247c3b6e4667192eaad5e6f7649b5">&#9670;&nbsp;</a></span>rpc_client_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrpc__client__state__s.html">rpc_client_state_s</a> <a class="el" href="rpc_8h.html#a79d247c3b6e4667192eaad5e6f7649b5">rpc_client_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper structure which stores the basic state needed for an RPC server to manage a single RPC client. Note that the rpc_sv server interface here passes generic void* as client struct and does not assume you use this struct, so this struct is provided for convenience and using this struct is optional. The default implementation assumes the void <em>cl parameters to be a valid rpc_client_state_t</em> object;</p>
<p>A good way to use this structure is to 'inherit' it by putting it as the first element of your own client structure. Then you may pointer case freely between your own client structure and a rpc_client_state_t. </p>

</div>
</div>
<a id="a24d64c94011f903c5eda8c2aba5fdbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d64c94011f903c5eda8c2aba5fdbf1">&#9670;&nbsp;</a></span>seL4_CSlot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef seL4_CPtr <a class="el" href="rpc_8h.html#a24d64c94011f903c5eda8c2aba5fdbf1">seL4_CSlot</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afb766fe0c62d1e62b33d3b23d441bb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb766fe0c62d1e62b33d3b23d441bb56">&#9670;&nbsp;</a></span>rpc_call_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rpc_call_server </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invoke the server. The destination endpoint may be automatically determined from the label for simplicity, unless overridden by a call to <a class="el" href="rpc_8c.html#a4a11e004e4e8f5228ba37f9bb51186c5">rpc_set_dest</a>. </p><dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero otherwise. </dd></dl>

</div>
</div>
<a id="afd1ff8159a2e2610fe0e3c031167ffe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1ff8159a2e2610fe0e3c031167ffe5">&#9670;&nbsp;</a></span>rpc_copyout_cptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a> rpc_copyout_cptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new cslot, and then copy out the given recieved capabiliy from the recieve cslot to a new cslot. This function exists to optionally separate <a class="el" href="rpc_8c.html#a14e46915864f9c8818a4883c0488a760">rpc_pop_cptr</a> from allocating a new cslot. This function useful in the case where allocating a cslot itself requires an RPC call, as RPC calling from <a class="el" href="rpc_8c.html#a14e46915864f9c8818a4883c0488a760">rpc_pop_cptr</a> may result in munging the IPC buffer. This function may need to temporarily copy the given cap to an empty slot, in order to IPC to allocate a new cslot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>CSpace pointer to capability to copy out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSpace pointer to copied out capability. </dd></dl>

</div>
</div>
<a id="a00da1d638d4ac11a9ca02ddfe797e323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00da1d638d4ac11a9ca02ddfe797e323">&#9670;&nbsp;</a></span>rpc_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the given object at memory address. Works like cstdlib free(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address ti free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f74ad32a1e217937df9ed512847e5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f74ad32a1e217937df9ed512847e5da">&#9670;&nbsp;</a></span>rpc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tradstdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise client state, ready for a new RPC call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name_str</td><td>Name of call being initiated (for easier debugging, may ignore this). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>The call enum label which server will use to identify which call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ba5faebcc6de15dbe556d0962c794a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba5faebcc6de15dbe556d0962c794a3">&#9670;&nbsp;</a></span>rpc_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rpc_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A helper function to allocate &amp; manage the allocated memory for an RPC. Works like cstdlib malloc(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>Size of memory to allocate in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated memory. </dd></dl>

</div>
</div>
<a id="ae6b1c202902aba304be2e5efc10f2a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b1c202902aba304be2e5efc10f2a99">&#9670;&nbsp;</a></span>rpc_pop_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_pop_buf </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next generic buffer object from current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to allocated buffer object to read into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>Size of generic object to read in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf1f4220191c751b7ee4de8f826a401b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1f4220191c751b7ee4de8f826a401b">&#9670;&nbsp;</a></span>rpc_pop_buf_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_pop_buf_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next buffer object array from current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to allocated buffer object to read into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>Size of generic object to read in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Max. number of objects in array (only used for checking). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14e46915864f9c8818a4883c0488a760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e46915864f9c8818a4883c0488a760">&#9670;&nbsp;</a></span>rpc_pop_cptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a> rpc_pop_cptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next capability from current global RPC packet. Note that this function may choose to copy out the recieved cap from the recieve slot in this function and leave an empty stub in rpc_copyout_cptr, or alternatively it may just simply return the recieve slot here and then implement copyout in rpc_copyout_cptr. See <a class="el" href="rpc__refos_8c.html#a359448914c4cb2fde1312e3671e534d5">rpc_copyout_cptr</a>. </p><dl class="section return"><dt>Returns</dt><dd>CSpace pointer to recieved capability. </dd></dl>

</div>
</div>
<a id="a1b4e8bc6b8d64ed0746a732bc162116f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4e8bc6b8d64ed0746a732bc162116f">&#9670;&nbsp;</a></span>rpc_pop_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_pop_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next C string from current global RPC packet. NOTE: Using a string as output is not safe in standard C function calls, and likewise it is also not a good idea at all for RPC calls, and is prone to buffer overflow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to allocated string to read into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea605785377d97fdd9c075d81c5cf7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea605785377d97fdd9c075d81c5cf7c9">&#9670;&nbsp;</a></span>rpc_pop_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rpc_pop_uint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next integer type variable from current global RPC packet. </p><dl class="section return"><dt>Returns</dt><dd>Value of next integer. </dd></dl>

</div>
</div>
<a id="a25315d6b4c5b0d16d49fc62a1a7f2029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25315d6b4c5b0d16d49fc62a1a7f2029">&#9670;&nbsp;</a></span>rpc_push_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_push_buf </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new generic buffer object to the end of the current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to buffer obj to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>Size of the buffer obj in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6acf893243f2d8cacdebec0bfcdcb805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acf893243f2d8cacdebec0bfcdcb805">&#9670;&nbsp;</a></span>rpc_push_buf_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_push_buf_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new array of generic buffer objects to the end of the current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to array of buffer objects to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>Size of a single buffer obj in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of objects in v. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac37573ea2f169dec545d9baf39b1817f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37573ea2f169dec545d9baf39b1817f">&#9670;&nbsp;</a></span>rpc_push_cptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_push_cptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new capablity to the end of the current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Capability to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80f50c90705ab9cf1affb1ddd7dd368d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f50c90705ab9cf1affb1ddd7dd368d">&#9670;&nbsp;</a></span>rpc_push_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_push_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tradstdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new C string type variable to the end of the current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>String to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7daffff567cae2d89516946caa8981fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7daffff567cae2d89516946caa8981fd">&#9670;&nbsp;</a></span>rpc_push_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_push_uint </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new integer type variable to the end of the current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Value of integer to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53b7a3ec607ccb55ff1e0a667f2047f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b7a3ec607ccb55ff1e0a667f2047f1">&#9670;&nbsp;</a></span>rpc_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finish up the current client RPC call and release all allocated objects. </p>

</div>
</div>
<a id="a0231178aaf29570b84ef4cf65aebf5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0231178aaf29570b84ef4cf65aebf5c7">&#9670;&nbsp;</a></span>rpc_reset_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_reset_contents </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the data pointers (e.g. current IPC MR number and cap number) in the client's send buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure (optional). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a11e004e4e8f5228ba37f9bb51186c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a11e004e4e8f5228ba37f9bb51186c5">&#9670;&nbsp;</a></span>rpc_set_dest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_set_dest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a>&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a custom destination endpoint. By default the destination endpoint used is the one specified in the interface XML file. To support interfaces which make sense to be served by multiple servers, the IDL param mode='connect_ep' is used. CIDL will see this flag and call this function with the marked parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Destination server endpoint that the next rpc_call_server will invoke. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c85e176e6dd23cc5ae050cd32f49971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c85e176e6dd23cc5ae050cd32f49971">&#9670;&nbsp;</a></span>rpc_setup_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_setup_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpc_8h.html#aff283406e5bd55d19158ac73d498fc1f">cslot</a>&#160;</td>
          <td class="paramname"><em>recv_cslot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the given cslot as the destination slot for cap transfer. If this isn't called explicitly, the provided client/server interface below should automatically call this with a default cslot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recv_cslot</td><td>CSpace slot to use to recieve caps. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f3ab7b09834f82b466a07e2b309dbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3ab7b09834f82b466a07e2b309dbad">&#9670;&nbsp;</a></span>rpc_setup_recv_cspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_setup_recv_cspace </td>
          <td>(</td>
          <td class="paramtype">seL4_CPtr&#160;</td>
          <td class="paramname"><em>cspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">seL4_CPtr&#160;</td>
          <td class="paramname"><em>recv_cslot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">seL4_Word&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the given cslot as the destination slot for cap transfer. This version does not assume default cspace. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cspace</td><td>Root of the thread's CSpace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recv_cslot</td><td>Address of CSpace slot to use to recieve caps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Number of bits of the capability address to be translated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9610abab3174984d910bf32931585ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9610abab3174984d910bf32931585ae">&#9670;&nbsp;</a></span>rpc_sv_free_tracked_objs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_sv_free_tracked_objs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae906346e779efb2ccf1535a35bb6093c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae906346e779efb2ccf1535a35bb6093c">&#9670;&nbsp;</a></span>rpc_sv_get_reply_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a> rpc_sv_get_reply_endpoint </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the saved reply endpoint if it has been saved, or 0 otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>saved reply endpoint if it was saved, 0 otherwise to reply immediately. </dd></dl>

</div>
</div>
<a id="a6c296bc474e8fe39853385adab0d9dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c296bc474e8fe39853385adab0d9dee">&#9670;&nbsp;</a></span>rpc_sv_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_sv_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise server's client state, ready for a new RPC call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e89da3619f520a53c0fc25d2b4d15ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e89da3619f520a53c0fc25d2b4d15ac">&#9670;&nbsp;</a></span>rpc_sv_pop_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_sv_pop_buf </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read next buffer object from recieved RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Allocated buffer obj to read into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>Size of buffer object in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd39c115485186d20a4f2a17d053d385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd39c115485186d20a4f2a17d053d385">&#9670;&nbsp;</a></span>rpc_sv_pop_buf_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpc_8h.html#a432b131f8da6c189061eed2edb768581">rpc_buffer_t</a> rpc_sv_pop_buf_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read next array of buffer objects from recieved RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>Size of a single buffer object in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated and read buffer obj array. </dd></dl>

</div>
</div>
<a id="aabd125230d672f6101fa5d2a0f34ee0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd125230d672f6101fa5d2a0f34ee0b">&#9670;&nbsp;</a></span>rpc_sv_pop_cptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a> rpc_sv_pop_cptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read next capability from recieved RPC packet. For an unwrapped capability, the unwrapped badge value is returned from this function. In the case of a transferred cap, it is <em>NOT</em> copied out here (i.e. the value of recv_cslot in given <a class="el" href="rpc_8c.html#afa77bdc4991a307be437d3c69589f28e">rpc_setup_recv</a> is simply returned. It is up to the server handler to copy out given transferred caps. It is also up to the server handler to know (and check) which caps are unwrapped and which are transferred. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next capability. </dd></dl>

</div>
</div>
<a id="aa69f53755ee46967c62259b75cb72f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69f53755ee46967c62259b75cb72f53">&#9670;&nbsp;</a></span>rpc_sv_pop_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rpc_sv_pop_str </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read next string from recieved RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated and read string. </dd></dl>

</div>
</div>
<a id="a1b648766008f486faa723471e3ec3d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b648766008f486faa723471e3ec3d95">&#9670;&nbsp;</a></span>rpc_sv_pop_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rpc_sv_pop_uint </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read next integer from recieved RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next integer in packet. </dd></dl>

</div>
</div>
<a id="a8bef57f9167df839ca40abf7690704b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bef57f9167df839ca40abf7690704b8">&#9670;&nbsp;</a></span>rpc_sv_push_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_sv_push_buf </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new buffer object to the end of the current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to buffer object to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size of the given buffer object in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a4025f75161f7196bdf4285344a37df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4025f75161f7196bdf4285344a37df">&#9670;&nbsp;</a></span>rpc_sv_push_buf_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_sv_push_buf_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rpc_8h.html#a432b131f8da6c189061eed2edb768581">rpc_buffer_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of objects to the end of the current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A value rpc_buffer_t containing pointer to buffer and count info. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size of the a single object in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a415ca1ae9aa2312dcae2f682d3b3a08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415ca1ae9aa2312dcae2f682d3b3a08c">&#9670;&nbsp;</a></span>rpc_sv_push_cptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_sv_push_cptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rpc_8h.html#ac2fe238ddd149399555edc5f291dc58d">ENDPT</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a capability to the end of the current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>CPtr to capability to add and transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4844c1ac1b6000e81b63d1da25d0f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4844c1ac1b6000e81b63d1da25d0f58">&#9670;&nbsp;</a></span>rpc_sv_push_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_sv_push_uint </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new integer variable to the end of the current global RPC packet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>String to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a992636b31f73aecf3c21171c053b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a992636b31f73aecf3c21171c053b67">&#9670;&nbsp;</a></span>rpc_sv_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_sv_release </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End the current RPC for the given client caller and release all tis allocated objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef89317c2e6249f857f0a34a72fbe6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef89317c2e6249f857f0a34a72fbe6b0">&#9670;&nbsp;</a></span>rpc_sv_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_sv_reply </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply to the client RPC. Depending on whether the reply is immediate or saved-first then replied later, this function should send to the correct corresponding reply endpoint in either case. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9fff57b68be8d696b60c5a9152874b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fff57b68be8d696b60c5a9152874b6">&#9670;&nbsp;</a></span>rpc_sv_save_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rpc_sv_save_reply </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optionally save the current client RPC reply cap to reply later. A default weak definition is provided, and servers may want to override this. If this function returns True, the generated reply_*() functions are not called and must be invoked manually by the server. Useful for implementing server-side asynchronous syscalls which providing a synchronous syscall interface to clients. You may RPC from this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cl</td><td>Generic reference to caller client state structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False to reply immediately, True if the reply endpoint was saved. </dd></dl>

</div>
</div>
<a id="a9079d9a7e2b8c9a93163a96226823676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9079d9a7e2b8c9a93163a96226823676">&#9670;&nbsp;</a></span>rpc_sv_skip_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rpc_sv_skip_reply </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a1c7c356fc93b95454f9a132e0b6fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1c7c356fc93b95454f9a132e0b6fd4">&#9670;&nbsp;</a></span>rpc_sv_track_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rpc_sv_track_obj </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_6719ab1f1f7655efc2fa43f7eb574fd1.html">libs</a></li><li class="navelem"><a class="el" href="dir_e1f5680096cde1ba172dd0a26cecf023.html">librefos</a></li><li class="navelem"><a class="el" href="dir_4edadee5b8d2d92bd69056f9c1d43ce3.html">include</a></li><li class="navelem"><a class="el" href="dir_0aa40e55fe60d7bf574b9865c476ae95.html">refos-rpc</a></li><li class="navelem"><a class="el" href="rpc_8h.html">rpc.h</a></li>
    <li class="footer">Generated on Sat Jun 10 2023 17:16:02 for RefOS by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
