# seL4プロジェクトの構成とビルド

このページではこのビルドシステムを使用しているプロジェクトと対話し、
ビルドする方法について説明します。新しいプロジェクトの開発については
[ビルドシステムを組み込む](incorporating_into_project.md)を参照してください。

### 基本的なビルドの初期化

まず、seL4ベースのプロジェクトのルートディレクトリで出力バイナリのための
個別のビルドディレクトリを作成し、CMakeを初期化します。

```bash
mkdir build
cd build
cmake -DCROSS_COMPILER_PREFIX=arm-linux-gnueabi- -DCMAKE_TOOLCHAIN_FILE=../kernel/gcc.cmake <OTHER_COMMAND_LINE_OPTIONS_HERE> -G Ninja ..
```

このcmakeは次の各要素で構成されています。

- `-D`は`X=Y`という形で変数を定義します。
- `CROSS_COMPILER_PREFIX`はクロスコンパイル用のツールチェーンを指定するもので
  あり、ビルドディレクトリの初期化後には変更することはできません。詳細は後述の
  「クロスコンパイル」を参照してください。
- `CMAKE_TOOLCHAIN_FILE`はCMakeが指定されたファイルを「ツールチェーン」
  ファイルとして読み込む必要があることを示します。ツールチェーンファイルは
  プロジェクトをビルドするためのCコンパイラやリンカなどを設定することが
  できます。この例では典型的なプロジェクトのレイアウトを想定しており、
  seL4はトップレベルの'kernel'ディレクトリに置かれています。seL4リポジトリに
  ある[gcc.cmake](https://github.com/seL4/seL4/blob/master/gcc.cmake)
  ファイルは`CROSS_COMPILER_PREFIX`を使用してCコンパイラとリンカをセットアップ
  します。
- `-G Ninja`はCMakeにGNU MakefileではなくNinjaビルドスクリプトを生成する
  よう指示します。カーネルの一部ではNinjaスクリプトだけがサポートされています。
- `..`は、このプロジェクトを記述するトップレベルの`CMakeLists.txt`ファイルの
  あるパスで、この例ではプロジェクトのルートディレクトリに置かれています。

また、上記をより短いコマンドに抽象化した省略記法のラッピングスクリプトも
用意されています。

```bash
../init-build -DCROSS_COMPILER_PREFIX=arm-linux-gnueabi- <COMMAND_LINE_OPTIONS_HERE>
```

構成が終わったらninjaを起動することでプロジェクトをビルドすることができます。

```bash
ninja
```

ビルドが完了すると作成されたバイナリは`images/`サブディレクトリに置かれます。

## 構成

### オプションの種類

CMakeには次の2種類の構成オプションがあります。

- *ブーリアンオプション*: `ON`, `OFF`のいずれかです
- *文字列オプション*: プロジェクトの作者が設定した制限にしたがい任意の値を
  設定することができます

文字列オプションは「ヒント」を持つことができ、いくつかの固定値から1つを指定
することができます。CMakeの構成エディタはこれを尊重し、ラジオボタンで選択
できるようにしています。

### オプションの選択

多くのプロジェクトでは構成オプションにより、ある程度のカスタマイズを可能に
しています。ビルドディレクトリを初期化したら、以下の方法でオプション設定の
ためのユーザインターフェイスを表示させることができます。

- `ncurses`ベースの構成
    ```bash
    ccmake .
    ```
- グラフィカルな構成
    ```bash
    cmake-gui .
    ```

どちらの場合も`.`パスはビルド構成で使用されたのと同じディレクトリに解決
されます。

### オプション値の変更

設定オプションの変更は、利用可能なオプションを変更する`(c)onfigure`を使って
明示的に要求しない限り、ユーザインターフェイスには反映されません。たとえば、
オプションAがブーリアンオプションBに依存している場合、Bが有効にされ、
`(c)onfigure`を使ってCMakeファイルを再処理するま、Aは表示されません。

構成インタフェースを終了するには`(g)enerate and exit`、または、
`(q)uit without generation`を使用します。構成が不完全な場合、CMakeは
生成を許可しません（`(c)onfigure`を実行してすべてのオプションを設定する
必要があります）。

構成オプションの変更後に再構築するには、ninjaを起動します。

```bash
ninja
```

### 初期構成

プロジェクトの多くは複数の構成をサポートしており、以下のような幅広い
アプローチでユーザにシンプルなオプションを提供しています。

- **CMakeキャッシュスクリプト**: これらのファイルは任意の数の構成変数に
  これらを組み合わせることでシステム全体を構成することができます。
- **メタコンフィギュレーションオプション**: メタコンフィギュレーション
  オプションは、通常、初期コマンドライン引数`-DVAR=FOO`としてCMakeに
  渡され、プロジェクトのCMakeスクリプトによりプログラム的に検査され、
  システムの（再）構成の使用されます。

#### CMakeキャッシュスクリプト

CMakeキャッシュスクリプトは事前設定したオプションのサブセットを提供します。
これによりプロジェクトのユーザは各オプションを手で設定しなくてもすみます。
キャッシュスクリプトは`.cmake`というファイル拡張子を持ちます。

プロジェクトは一つの機能またはオプションの構成に必要なキャッシュ設定を
持つ複数のキャッシュスクリプトファイルを提供することができます。複数の
`.cmake`ファイルを組み合わせることでプロジェクトを特定の方法で初期化する
ことができます。キャッシュスクリプトの構成はビルドディレクトリの初期化の際に
`cmake`に`-C <file>`を渡すことで提供されます。たとえば、典型的なプロジェクト
構造の場合、いくつかのキャッシュスクリプトを引数として`cmake`または
`init-build.sh`を起動することになります。

複数のキャッシュスクリプトをコマンドラインでは指定できますが、同じオプションが
2回設定された場合は1つの値しか使用されません。例として、アーキテクチャの詳細
設定用のキャッシュスクリプト（`arm.cmake`、`x86.cmake`）とビルドオプション
設定用のキャッシュスクリプト（`debug.cmake`、`release.cmake`）がそれぞれ複数
ある場合を考えます。意図した使い方は、以下のようにアーキテクチャキャッシュ
ファイルを1つとビルドオプションファイルを1つ使用することです。

```bash
cmake -C../projects/awesome_project/configs/arm.cmake -C../projects/awesome_project/configs/debug.cmake -DCROSS_COMPILER_PREFIX=arm-linux-gnueabi- -DCMAKE_TOOLCHAIN_FILE=../kernel/gcc.cmake -G Ninja ..
```

`arm.cmake`と`x86.cmake`を同時に使用することを妨げるものはありませんが、
これは意味がないので、各オプションの値は1つだけ使用されることになります。
複数のキャッシュスクリプトを持つプロジェクトでは、どのキャッシュスクリプトを
一緒に使用できるかを確認する必要があります。

#### メタ構成オプション

seL4プロジェクトの中には複数のプロジェクトで使用される同じ動作をするトップ
レベルの変数を提供するものがあります。これらのオプションは以下の通りです。

- `-DPLATFORM=<YOUR_PREFERENCE>`: 生成されるバイナリのターゲットシステムを
  選択します。この変数に指定できる値は各アーキテクチャの`config_choice`ディレク
  ティブの最初の値（セミコロンの前の値）です（**訳注**: この情報は古いようだ。
  buildディレクトリの`CMakeCache.txt`の`PLATFORM-STRINGS`に各種cmake処理後の
  有効値がリストアップされている。`rpi3`は[ここで定義](https://github.com/seL4/seL4/blob/master/src/plat/bcm2837/config.cmake#L21)されていると思われる）。
    - ARMの場合： [ソース中のリスト](https://github.com/seL4/seL4/blob/master/src/arch/arm/config.cmake#L21)
    - X86の場合： [ソース中のリスト](https://github.com/seL4/seL4/blob/master/src/arch/x86/config.cmake#L15)
    - RISC-Vの場合： [ソース中のリスト](https://github.com/seL4/seL4/blob/master/src/arch/riscv/config.cmake#L15)

- `-DRELEASE`: `0`または`1`に設定します。オフにするとデバッグビルドがコンパイル
  されます。オンにするとデバッグ機能を有効にせずにプロジェクトをコンパイル
  します。
- `-DVERIFICATION`] `0`または`1`に設定します。**VERIFIABLE**なseL4カーネル
  ソースバージョンを生成するために使用されます。**検証された**カーネルプラット
  フォーム用のバイナリは生成しません。
- `-DSMP`: `0`または`1`に設定します。SMP（対称型マルチプロセッシング）
  サポートのオン/オフを切り替えます。デフォルトでは最大4プロセッサのサポートが
  有効になります。サポートするCPUの最大数を明示的に設定するには、`-DKernelMaxNumNodes=<YOUR_PREFERENCE>`を設定してみてください。
- `-DSIMULATION`: `0`または`1`に設定: QEMUなどのエミュレータで実行するのに
  適したプロジェクトのビルドを作成します。

[seL4test](https://docs.sel4.systems/seL4Test)プロジェクトと
[seL4bench](https://github.com/seL4/sel4bench-manifest)プロジェクトは共に
この形式を採用しています。

#### [sel4test](https://github.com/seL4/sel4test)の例

sel4testスイートの構成、ビルド、実行の詳細については
[seL4testのメインページ](https://docs.sel4.systems/seL4Test)を参照してください。

### クロスコンパイル

[クロスコンパイル](https://en.wikipedia.org/wiki/Cross_compiler)とは、
プログラムのコンパイルに使用しているマシンとは異なるターゲットマシン用に
プログラムをコンパイルすることを言います。

一般に、クロスコンパイルを行うにはターゲットとなるマシンに特化したコンパイラが
別途必要です。

#### ARMベースのターゲットの場合

ARMベースのマシン用にクロスコンパイルする場合、以下のコマンドラインオプションを
使用することができます。

- `-DAARCH32=TRUE`: 32ビットARMターゲット用にビルドすることをビルドシステムに
  指示します。これにより、ビルドシステムはトリプレット名`arm-linux-gnueabi-`を
  持つシステムをターゲットとするクロスコンパイラがインストールされていると判断
  します。
- `-DAARCH32HF=TRUE`: ハードウェア浮動小数点サポートがある32ビットARM
  ターゲット用にビルドすることをビルドシステムに指示します。
  `arm-linux-gnueabihf-`をターゲットとするクロスコンパイラがインストールされて
  いることを仮定します。
- `-DAARCH64=TRUE`: 64ビットARMターゲット用にビルドすることをビルドシステムに
  指示します。`aarch64-linux-gnu-`をターゲットとするクロスコンパイラが
  インストールされていることを仮定します。

また、`-DCROSS_COMPILER_PREFIX`でツールチェーンを明示的に指定することも
できます。これは使用するクロスコンパイラのプレフィックスの設定に使用します。

#### RISC-Vベースのターゲットの場合

RISC-Vターゲット用にクロスコンパイルする場合、以下のオプションを使用する
ことができます。

- `-DRISCV32=TRUE`: 32ビットRISC-Vターゲット用にビルドすることをビルド
  システムに指示します。これにより、ビルドシステムはトリプレット名
  `riscv32-unknown-elf-`を持つシステムをターゲットとするクロスコンパイラが
  インストールされていると判断します。
- `-DRISCV64=TRUE`: 64ビットRISC-Vターゲット用にビルドすることをビルド
  システムに指示します。`riscv64-unknown-elf-`をターゲットとするクロス
  コンパイラがインストールされていることを仮定します。

ARMと同様に`-DCROSS_COMPILER_PREFIX`を使用してツールチェーンを明示的に
指定することができ、使用するクロスコンパイラのプレフィックスを設定する
ことができます。

#### CMAKE_BUILD_TYPE

CMake構成エディターには`CMAKE_BUILD_TYPE`オプションが表示されます。これを
使ってユーザはそのビルドタイプ（リリース、デバッグなど）を設定することが
できます。このオプションはseL4カーネルでは尊重されないことに注意してください。

### Clangを使ったビルド

カーネルとその他いくつかのプロジェクトは[clang](https://clang.llvm.org/)
コンパイラを使ってビルドすることができます。この構成を選択するには、初期
構成段階で`-DTRIPLE`変数を設定する必要があります（`init-build`スクリプトの
引数として渡します）。

`TRIPLE`の値はコンパイルする[ターゲット](https://releases.llvm.org/8.0.0/tools/clang/docs/CrossCompilation.html#target-triple)である必要があります。

```bash
../init-build -DTRIPLE=x86_64-linux-gnu <COMMAND_LINE_OPTIONS_HERE>
```

`CROSS_COMPILER_PREFIX`引数はclangでコンパイルする場合は不要であり、
無視されます。armベースのターゲット用にビルドする場合、ターゲットの`TRIPLE`は
末尾の'-'を削除した`CROSS_COMPILER_PREFIX`（gccを使用する場合）と同じ値です。

RISC-Vベースのターゲット用のコンパイルにclangを使用することは現在サポート
されていません。
